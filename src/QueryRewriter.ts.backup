import {
  ExprContext,
  Expr6Context,
  Expr15Context,
  Expr17Context,
  Expr18Context,
  BlockOrBarContext,
  QuantDeclListContext,
} from "./forge-antlr/ForgeParser";
import { ForgeParser } from "./forge-antlr/ForgeParser";
import { CharStreams, CommonTokenStream } from "antlr4ts";
import { ForgeLexer } from "./forge-antlr/ForgeLexer";
import { ParseErrorListener } from "./errorListener";

/**
 * Query rewriter that applies algebraic equivalences to optimize comprehensions
 * before evaluation. This implements the optimizations described in the issue:
 * 
 * A. Field equality to direct relation: {a,b | a.f = b} ⇒ f
 * B. Existential join fusion: {a,b | some t | a = t.f0 and b = t.f1} ⇒ ~f0 . f1
 * C. Membership in a join: {a,b | b in a.r} ⇒ r
 * D. Membership with guard on second component: {a,b | a->b in R and b ∈ S} ⇒ R & (UNIV -> S)
 * E. Mutual reachability via closure: {a,b | a->b in ^E and b->a in ^E} ⇒ (^E) & ~(^E)
 * F. Nonreflexive pairs: {a,b | a!=b and a->b in R} ⇒ R - iden
 */

/**
 * Result of attempting to rewrite an expression.
 */
export interface RewriteResult {
  rewritten: boolean;
  expression: string;
  patternApplied?: string;
}

/**
 * Parse an expression into an ExprContext.
 */
function parseExpression(expr: string): ExprContext | null {
  try {
    const inputStream = CharStreams.fromString(expr);
    const lexer = new ForgeLexer(inputStream);
    const tokenStream = new CommonTokenStream(lexer);
    const parser = new ForgeParser(tokenStream);
    parser.buildParseTree = true;
    parser.removeErrorListeners();
    parser.addErrorListener(new ParseErrorListener());
    const tree = parser.parseExpr();
    
    if (!tree || tree.childCount === 0) {
      return null;
    }
    
    // Get the expr() from the parseExpr context
    return tree.expr();
  } catch (e) {
    return null;
  }
}

/**
 * Main rewriter class that applies algebraic optimizations to set comprehensions.
 */
export class QueryRewriter {
  /**
   * Attempt to rewrite a comprehension expression using algebraic equivalences.
   * @param expression The expression to potentially rewrite
   * @returns Result indicating if rewrite was applied and the resulting expression
   */
  public rewrite(expression: string): RewriteResult {
    const ctx = parseExpression(expression);
    if (!ctx) {
      return { rewritten: false, expression };
    }

    // Try each rewrite pattern in sequence
    const patterns = [
      this.tryRewriteFieldEquality.bind(this),
      this.tryRewriteMembershipInJoin.bind(this),
      this.tryRewriteMembershipWithGuard.bind(this),
      this.tryRewriteMutualReachability.bind(this),
      this.tryRewriteNonreflexivePairs.bind(this),
      // Pattern B (existential join fusion) is more complex and requires nested quantifier handling
      // We'll implement it after the simpler patterns
    ];

    for (const pattern of patterns) {
      const result = pattern(ctx, expression);
      if (result.rewritten) {
        return result;
      }
    }

    return { rewritten: false, expression };
  }

  /**
   * Pattern A: Field equality to direct relation
   * {a,b | a.f = b} ⇒ f
   * 
   * Also handles: {a,b | b = a.f} (commutative case)
   */
  private tryRewriteFieldEquality(ctx: ExprContext, original: string): RewriteResult {
    const parts = this.extractComprehensionParts(ctx);
    if (!parts || parts.vars.length !== 2) {
      return { rewritten: false, expression: original };
    }

    const [var1, var2] = parts.vars;
    const constraintText = parts.constraintExpr.text;

    // Check for pattern: a.f = b or b = a.f
    const pattern1 = this.matchesPattern(parts.constraintExpr, `${var1}\\.([a-zA-Z_][a-zA-Z0-9_]*)=${var2}`);
    const pattern2 = this.matchesPattern(parts.constraintExpr, `${var2}=${var1}\\.([a-zA-Z_][a-zA-Z0-9_]*)`);
    
    if (pattern1) {
      return {
        rewritten: true,
        expression: pattern1[1],
        patternApplied: 'A: Field equality to direct relation'
      };
    }
    
    if (pattern2) {
      return {
        rewritten: true,
        expression: pattern2[1],
        patternApplied: 'A: Field equality to direct relation'
      };
    }

    return { rewritten: false, expression: original };
  }

  /**
   * Pattern C: Membership in a join
   * {a,b | b in a.r} ⇒ r
   * 
   * Also handles: {a,b | a->b in r} ⇒ r
   */
  private tryRewriteMembershipInJoin(ctx: ExprContext, original: string): RewriteResult {
    const parts = this.extractComprehensionParts(ctx);
    if (!parts || parts.vars.length !== 2) {
      return { rewritten: false, expression: original };
    }

    const [var1, var2] = parts.vars;

    // Pattern: b in a.r
    const pattern1 = this.matchesPattern(parts.constraintExpr, `${var2}in${var1}\\.([a-zA-Z_][a-zA-Z0-9_]*)`);
    if (pattern1) {
      return {
        rewritten: true,
        expression: pattern1[1],
        patternApplied: 'C: Membership in a join'
      };
    }

    // Pattern: a->b in r
    const pattern2 = this.matchesPattern(parts.constraintExpr, `${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)`);
    if (pattern2) {
      return {
        rewritten: true,
        expression: pattern2[1],
        patternApplied: 'C: Membership in a join (arrow form)'
      };
    }

    return { rewritten: false, expression: original };
  }

  /**
   * Pattern D: Membership with guard on second component
   * {a,b | a->b in R and b ∈ S} ⇒ R & (UNIV -> S)
   * 
   * Also handles other orderings: b ∈ S and a->b in R
   */
  private tryRewriteMembershipWithGuard(ctx: ExprContext, original: string): RewriteResult {
    const parts = this.extractComprehensionParts(ctx);
    if (!parts || parts.vars.length !== 2) {
      return { rewritten: false, expression: original };
    }

    const [var1, var2] = parts.vars;

    // Look for "and" conjunction - check for both "and" and "&&"
    // Pattern: a->b in R and b in S  OR  b in S and a->b in R
    
    // Try: a->b in R and b in S
    const pattern1 = this.matchesPattern(
      parts.constraintExpr,
      `${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)and${var2}in([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern1) {
      const R = pattern1[1];
      const S = pattern1[2];
      return {
        rewritten: true,
        expression: `${R} & (univ -> ${S})`,
        patternApplied: 'D: Membership with guard on second component'
      };
    }

    // Try: b in S and a->b in R
    const pattern2 = this.matchesPattern(
      parts.constraintExpr,
      `${var2}in([a-zA-Z_][a-zA-Z0-9_]*)and${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern2) {
      const S = pattern2[1];
      const R = pattern2[2];
      return {
        rewritten: true,
        expression: `${R} & (univ -> ${S})`,
        patternApplied: 'D: Membership with guard on second component'
      };
    }

    // Also try with && instead of "and"
    const pattern3 = this.matchesPattern(
      parts.constraintExpr,
      `${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)&&${var2}in([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern3) {
      const R = pattern3[1];
      const S = pattern3[2];
      return {
        rewritten: true,
        expression: `${R} & (univ -> ${S})`,
        patternApplied: 'D: Membership with guard on second component'
      };
    }

    const pattern4 = this.matchesPattern(
      parts.constraintExpr,
      `${var2}in([a-zA-Z_][a-zA-Z0-9_]*)&&${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern4) {
      const S = pattern4[1];
      const R = pattern4[2];
      return {
        rewritten: true,
        expression: `${R} & (univ -> ${S})`,
        patternApplied: 'D: Membership with guard on second component'
      };
    }

    return { rewritten: false, expression: original };
  }

  /**
   * Pattern E: Mutual reachability via closure
   * {a,b | a->b in ^E and b->a in ^E} ⇒ (^E) & ~(^E)
   * 
   * Also handles && instead of "and"
   */
  private tryRewriteMutualReachability(ctx: ExprContext, original: string): RewriteResult {
    const parts = this.extractComprehensionParts(ctx);
    if (!parts || parts.vars.length !== 2) {
      return { rewritten: false, expression: original };
    }

    const [var1, var2] = parts.vars;

    // Pattern: a->b in ^E and b->a in ^E
    const pattern1 = this.matchesPattern(
      parts.constraintExpr,
      `${var1}->${var2}in\\^([a-zA-Z_][a-zA-Z0-9_]*)and${var2}->${var1}in\\^([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern1 && pattern1[1] === pattern1[2]) {
      const E = pattern1[1];
      return {
        rewritten: true,
        expression: `(^${E}) & ~(^${E})`,
        patternApplied: 'E: Mutual reachability via closure'
      };
    }

    // Try with &&
    const pattern2 = this.matchesPattern(
      parts.constraintExpr,
      `${var1}->${var2}in\\^([a-zA-Z_][a-zA-Z0-9_]*)&&${var2}->${var1}in\\^([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern2 && pattern2[1] === pattern2[2]) {
      const E = pattern2[1];
      return {
        rewritten: true,
        expression: `(^${E}) & ~(^${E})`,
        patternApplied: 'E: Mutual reachability via closure'
      };
    }

    // Try reversed order: b->a in ^E and a->b in ^E
    const pattern3 = this.matchesPattern(
      parts.constraintExpr,
      `${var2}->${var1}in\\^([a-zA-Z_][a-zA-Z0-9_]*)and${var1}->${var2}in\\^([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern3 && pattern3[1] === pattern3[2]) {
      const E = pattern3[1];
      return {
        rewritten: true,
        expression: `(^${E}) & ~(^${E})`,
        patternApplied: 'E: Mutual reachability via closure'
      };
    }

    const pattern4 = this.matchesPattern(
      parts.constraintExpr,
      `${var2}->${var1}in\\^([a-zA-Z_][a-zA-Z0-9_]*)&&${var1}->${var2}in\\^([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern4 && pattern4[1] === pattern4[2]) {
      const E = pattern4[1];
      return {
        rewritten: true,
        expression: `(^${E}) & ~(^${E})`,
        patternApplied: 'E: Mutual reachability via closure'
      };
    }

    return { rewritten: false, expression: original };
  }

  /**
   * Pattern F: Nonreflexive pairs
   * {a,b | a!=b and a->b in R} ⇒ R - iden
   * 
   * Also handles: {a,b | not a=b and a->b in R}
   */
  private tryRewriteNonreflexivePairs(ctx: ExprContext, original: string): RewriteResult {
    const parts = this.extractComprehensionParts(ctx);
    if (!parts || parts.vars.length !== 2) {
      return { rewritten: false, expression: original };
    }

    const [var1, var2] = parts.vars;

    // Pattern: a!=b and a->b in R
    const pattern1 = this.matchesPattern(
      parts.constraintExpr,
      `${var1}!=${var2}and${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern1) {
      return {
        rewritten: true,
        expression: `${pattern1[1]} - iden`,
        patternApplied: 'F: Nonreflexive pairs'
      };
    }

    // Try reversed: a->b in R and a!=b
    const pattern2 = this.matchesPattern(
      parts.constraintExpr,
      `${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)and${var1}!=${var2}`
    );
    if (pattern2) {
      return {
        rewritten: true,
        expression: `${pattern2[1]} - iden`,
        patternApplied: 'F: Nonreflexive pairs'
      };
    }

    // Try with &&
    const pattern3 = this.matchesPattern(
      parts.constraintExpr,
      `${var1}!=${var2}&&${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern3) {
      return {
        rewritten: true,
        expression: `${pattern3[1]} - iden`,
        patternApplied: 'F: Nonreflexive pairs'
      };
    }

    const pattern4 = this.matchesPattern(
      parts.constraintExpr,
      `${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)&&${var1}!=${var2}`
    );
    if (pattern4) {
      return {
        rewritten: true,
        expression: `${pattern4[1]} - iden`,
        patternApplied: 'F: Nonreflexive pairs'
      };
    }

    // Try with "not a = b" instead of "a != b"
    const pattern5 = this.matchesPattern(
      parts.constraintExpr,
      `not${var1}=${var2}and${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)`
    );
    if (pattern5) {
      return {
        rewritten: true,
        expression: `${pattern5[1]} - iden`,
        patternApplied: 'F: Nonreflexive pairs'
      };
    }

    const pattern6 = this.matchesPattern(
      parts.constraintExpr,
      `${var1}->${var2}in([a-zA-Z_][a-zA-Z0-9_]*)andnot${var1}=${var2}`
    );
    if (pattern6) {
      return {
        rewritten: true,
        expression: `${pattern6[1]} - iden`,
        patternApplied: 'F: Nonreflexive pairs'
      };
    }

    return { rewritten: false, expression: original };
  }

  /**
   * Helper to check if an expression context is a set comprehension and extract its components.
   */
  private extractComprehensionParts(ctx: ExprContext): {
    vars: string[],
    constraintExpr: ExprContext
  } | null {
    // A set comprehension in the grammar looks like:
    // expr18: ... | LEFT_CURLY_TOK quantDeclList blockOrBar RIGHT_CURLY_TOK | ...
    // We need to check if ctx eventually leads to an expr18 with this structure
    
    // Navigate through the expression hierarchy
    // expr -> expr1 -> ... -> expr18
    
    // Start by trying to get to expr18
    let current: any = ctx;
    let attempts = 0;
    const maxAttempts = 20; // Prevent infinite loops
    
    while (attempts < maxAttempts) {
      attempts++;
      
      // Check if current context looks like an Expr18Context with comprehension
      if (current.LEFT_CURLY_TOK && typeof current.LEFT_CURLY_TOK === 'function') {
        const leftCurly = current.LEFT_CURLY_TOK();
        if (leftCurly) {
          // This is a comprehension!
          const quantDeclList = current.quantDeclList ? current.quantDeclList() : null;
          const blockOrBar = current.blockOrBar ? current.blockOrBar() : null;
          
          if (quantDeclList && blockOrBar) {
            const barTok = blockOrBar.BAR_TOK ? blockOrBar.BAR_TOK() : null;
            const expr = blockOrBar.expr ? blockOrBar.expr() : null;
            
            if (barTok && expr) {
              const vars = this.extractQuantDeclVars(quantDeclList);
              return { vars, constraintExpr: expr };
            }
          }
        }
      }
      
      // Try to navigate deeper in the expression hierarchy
      // Try common child methods in order of the grammar
      let found = false;
      const childMethods = ['expr1', 'expr1_5', 'expr2', 'expr3', 'expr4', 'expr4_5', 'expr5', 'expr6', 'expr7', 'expr8', 'expr9', 'expr10', 'expr11', 'expr12', 'expr13', 'expr14', 'expr15', 'expr16', 'expr17', 'expr18'];
      
      for (const method of childMethods) {
        if (current[method] && typeof current[method] === 'function') {
          const child = current[method]();
          // Handle both single context and array of contexts
          if (Array.isArray(child)) {
            // If it's an array, try the first element
            if (child.length > 0 && child[0] !== current) {
              current = child[0];
              found = true;
              break;
            }
          } else if (child && child !== current) { // Avoid infinite loops
            current = child;
            found = true;
            break;
          }
        }
      }
      
      if (!found) {
        break;
      }
    }
    
    return null;
  }

  /**
   * Extract variable names from quantDeclList.
   */
  private extractQuantDeclVars(quantDeclList: QuantDeclListContext): string[] {
    const vars: string[] = [];
    
    // Process each quantDecl in the list
    let current: QuantDeclListContext | undefined = quantDeclList;
    while (current) {
      const quantDecl = current.quantDecl();
      if (quantDecl) {
        const nameList = quantDecl.nameList();
        if (nameList) {
          // Extract names from nameList
          const names = this.extractNamesFromNameList(nameList);
          vars.push(...names);
        }
      }
      
      // Move to next quantDecl in list
      current = current.quantDeclList();
    }
    
    return vars;
  }

  /**
   * Extract names from a nameList.
   */
  private extractNamesFromNameList(nameList: any): string[] {
    const names: string[] = [];
    
    let current = nameList;
    while (current) {
      const name = current.name();
      if (name) {
        if (name.text) {
          names.push(name.text);
        }
      }
      
      current = current.nameList();
    }
    
    return names;
  }

  /**
   * Try to match an expression's text against a regex pattern.
   * Returns the captured groups if matched, null otherwise.
   */
  private matchesPattern(expr: ExprContext, pattern: string): RegExpMatchArray | null {
    const regex = new RegExp(`^${pattern}$`);
    return expr.text.match(regex);
  }
}
